{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BitMad","text":"<p>Some of my thoughts, ideas and projects thrown onto the web in the hope that someone can make use of something here.</p> <p>Mainly covering retro computing / electronics / computer stuff but there will no doubt be the odd random subject thrown in.</p> <p>This site is still in development but will slowly evolve into something great else, hopefully for the better.</p>"},{"location":"blog/C64ASMCLS/","title":"C64 ASM Clearing the screen","text":"<p>Clearing the screen is one of those things that is so trivial on the C64 that you can do it by pressing Shift + CLR or in basic by typing :- </p> <pre><code>PRINT CHR$(147)\n</code></pre> <p>It's not much more difficult to do it in assembly either thanks to the built in kernel routines of the C64.</p> <p>I'll show you how to clear the screen that way and then I'll show you another method which doesn't rely on the built in routines.</p> <p>Why wouldn't we always use the built in ones? They're BUILT IN! That's kind of the point of them right? No extra cost, no extra effort.</p> <p>Well, they're actually the BASIC routines that we're simply calling directly from assembly. If we have to overwrite basic in memory, we won't be able to use them anymore. (Need to confirm this. I'm sure there is a reason why you can't always use kernal routines.... but I could be wrong)</p> <p>OK, here is the code for the first method</p> <pre><code>*=$1000         ;load into $1000 (4096)\n\njsr $e544       ;jump to clear screen routine\nrts             ;ReTurn from Subroutine (End)\n</code></pre> <p>Now I shall go over each line and explain how the code works.\\ *=$1000 tells the assembler where to place our assembled code. This is our programs entry point.</p> <p>jsr $e544 This line tells the C64 to jump to memory address $e544. This memory address contains the kernal routines pointer.</p> <p>rts ends the program.</p> <p>Easy isn't it.</p> <p>Here is the code for the non-kernal method :-</p> <pre><code>*=$1000         ;load into $1000 (4096)\nldx #$00        ;load 0 into x register \nlda #$20        ;load $20(space char) into a register\nloop\nsta $0400,x     ;store contents of a ($20) into screen location $0400 + value of x\nsta $0500,x     ;store contents of a ($20) into screen location $0500 + value of x\nsta $0600,x     ;store contents of a ($20) into screen location $0600 + value of x\nsta $0700,x     ;store contents of a ($20) into screen location $0700 + value of x\ninx             ;increment x\nbne loop        ;while x doesn't equal 0, jump to loop\nrts             ;ReTurn from Subroutine (End)\n</code></pre> <p>*=$1000 tells the assembler where to place our assembled code. This is our programs entry point.</p> <p>ldx #$00 loads 0 directly into the x register</p> <p>lda #$20 loads the hex number 20 into the a register. $20 happens to be the character  code for the space character. We're going to write this \"character\" into every memory address for the screen to wipe it.</p> <p>loop - a label to show the start of our loop. We can call this anything.</p> <p>sta $0400,x This is the first line we'll use to write to the screen. $0400 is the memory address for the top left corner of the screen. The \",x\" after the memory address tells the computer to add the value of the x register to the $0400 number. On the first run, x is 0 so the data ($20) is written to memory location $0400 + 0. As the program loops, x will have 1 added to it so will continue to increase until it rolls back to 0.</p> <p>The next few lines do the same function but at different screen locations (I will explain later).</p> <p>inx - increment x, Add 1 to whatever is in the x register.</p> <p>bne loop - While x doesn't equal 0, go back to the loop.</p> <p>rts ends the program. </p> <p>The C64 screen is 1000 characters in size but our loop only allows us to count to 255 before it flips back to zero.</p> <p>This is why we have those 4 similar lines, each one points to the screen location 255 bytes after the first.</p> <p>If we were to slow the C64 down enough, we would see that our program writes 4 characters to the screen each time it loops until 4 sets of 255 characters have been written.</p> <p>I hope that someone finds this useful and please get in touch if I have made any mistakes.</p>"},{"location":"blog/C64intro/","title":"BitMad about.... Commodore 64","text":"<p>Growing up, I had a Commodore 64 (after a Dragon 32 and ZX Spectrum) and to this day it remains my favourite computer. That may be because I never had an Atari ST or Amiga back then so never knew what I was missing out on. Regardless, I still love the humble C64 and have decided that the 30 years since I last used the machine is quite long enough and I should try to learn all the stuff I wasn't clever enough to understand back then\u2026..not that I\u2019m any more intelligent now mind.</p> <p>There are so many great tools available these days for writing C64 code that you could be up and running at no cost in around 5-10 mins. IDEs, cross compilers, debuggers, everything you can think of is out there and can be used but for now, I'm going to use the \"real\" thing. By that I mean either a real C64 or an emulator, not a PC based development tool.</p> <p>The reason for this is because I feel that by using the C64 directly, I'll gain a better understanding of the machine. </p> <p>I actually started working on this article many weeks ago but kept on changing how I did things and then having to re-write parts. This is probably better for anyone wanting to follow along because at least now I have a fixed set of methods and tools whereas previously I would have been flicking between different applications.</p> <p>I'll use the term C64 from now on as a blanket term. Obviously there are many ways to facilitate this, from real hardware, emulator, replicas, etc. I have settled on 3 main methods for now (with a 4th planned) :-</p> <p>Real Commodore C64c - My own machine, stock firmware, no mods. Custom PSU (DO NOT USE THE ORIGINAL - article coming soon to explain why). Kung Fu Flash cartridge - Recently purchased.  Pi1541 - Bare PCB arrived this morning so will be built by the time this is published.</p> <p>MiSTer FPGA - I've had this for a few years now and absolutely love it. Expect some articles in the near future about it. The C64 core on the MiSTer is simply amazing. Great accuracy and the framework features add so many quality of life improvements while working with C64 media.</p> <p>Emulator - I tend to use Vice or Denise when using an emulator. Both are great and they're to hand on my laptop when I'm out and about or want to lay on the sofa and code.</p> <p>The C64 Maxi - I'm thinking of ordering one of these mainly for the keyboard. When using the MiSTer or an emulator, I use a Corsair K65 and have put stickers on some keycaps to identify special keys. I'd likely use the Maxi most of all because it blends the keyboard with the QOL improvements of emulation.</p> <p>Ok, on with the show. If I were writing this back in the 80s or 90s on real hardware, I'd probably have to choose software that most users already had or include a listing for it. I'm not. It's 2023 and emulators are filled to the brim with all the hardware you could wish for. The internet is awash with any software package you could imagine and you can find pretty much any information you desire either via web search or by downloading old C64 books. Life is just god damn peachy!</p> <p>Having owned an Action Replay mk6 cartridge back in the day, this was my first choice of utility cartridge. It was never unplugged from my machine in the 90s and it's always mounted when I run emulation. This time, it's different. For reasons that I will explain in a different article, I've opted for the Super Snapshot V5 cartridge.</p> <p>Regarding software, I've played with several different options but ultimately settled on Turbo Macro Pro (TMP). Initially I was put off by the menu system. From the few YouTube videos that I saw, it looked to me like I'd have to learn complicated shortcuts and command which I didn't fancy. Then I put my big boy pants on, looked at the docs and got stuck in.</p> <p>I did spend some time using Mikro Assembler by Supersoft and got on really well with it. I just found that TMP helped me to keep my code more organised. I had a quick look at the PAL assembler too but decided against it.</p> <p>Blank disks. I always keep a blank.d64 file handy and make copies when I need new disks. Some emulators have a feature to create a new blank disk and insert it which is nice. MiSTer doesn\u2019t have this feature hence the files.</p> <p>Documentation is another thing I've taken into account. I keep copies of these files with me while working with the C64 :-</p> <p>C64 User Manual C64 Programmers Reference Manual Super Snapshot V5 manual TMP Documentation</p> <p>This list will no doubt grow over time but it's what I consider the bare minimum for the time being. I did think about providing a zip file with everything included but quite honestly, these things are so easy to find that it's just not worth it. </p> <p>Most software / documentation can be found here :-\\ CSDB\\ Internet Archive\\</p> <p>Obviously this is just my choice and you are free to substitute any of the above should you choose to follow along. Many people nowadays use JiffyDOS / DolphinDOS or their own choice of utility cartridge. That is fine as most of what I will be covering will transfer between different methods.</p> <p>To each their own and may their C64 journey be eventful.</p>"}]}